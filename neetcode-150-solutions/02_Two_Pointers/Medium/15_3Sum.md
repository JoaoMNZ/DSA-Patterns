# <a href="https://leetcode.com/problems/3sum/" target="_blank">15. 3Sum</a>

### Problem Statement
Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

### Approach
The brute force approach would be to check every triplet, taking $O(N^3)$ time, which is too slow. We can optimize this to $O(N^2)$ using **Sorting** and the **Two Pointers** technique.

1.  **Sort the Array:** Sorting helps us in two ways:
    -   It allows us to efficiently find pairs that sum to a target using two pointers.
    -   It groups identical numbers together, making it easy to skip duplicates.

2.  **Iterate and Fix First Number:** We iterate through the array with index `i`. For each `nums[i]`, we need to find two other numbers that sum to `-nums[i]` (so the total sum is 0).

3.  **Two Pointers (Left and Right):**
    -   We set `left = i + 1` and `right = n - 1`.
    -   We calculate `sum = nums[i] + nums[left] + nums[right]`.
    -   If `sum < 0`, we need a larger number, so we increment `left`.
    -   If `sum > 0`, we need a smaller number, so we decrement `right`.
    -   If `sum == 0`, we found a valid triplet. We add it to the result.

4.  **Handling Duplicates:** This is the most critical part.
    -   **Outer Loop:** If `nums[i] == nums[i-1]`, we skip this iteration because we have already processed this number as the first element of a triplet.
    -   **Inner Loop:** After finding a valid triplet, we increment `left`. If the new `nums[left]` is the same as the previous one, we continue incrementing `left` to avoid adding the same triplet again.



### Implementation
```java
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        
        for(int i = 0 ; i < nums.length ; i++){
            // Optimization: If current number is positive, we can't sum to 0
            if(nums[i] > 0)
                break;
            
            // Skip duplicate starting numbers
            if(i > 0 && nums[i] == nums[i - 1])
                continue;

            int left = i + 1;
            int right = nums.length - 1;
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum > 0){
                    right--;
                }else if(sum < 0){
                    left++;
                }else{
                    res.add(List.of(nums[i], nums[left], nums[right]));
                    left++;
                    right--;
                    // Skip duplicate second numbers
                    while (left < right && nums[left] == nums[left - 1]) {
                        left++;
                    }
                }
            }
        }
        
        return res;
    }
}
